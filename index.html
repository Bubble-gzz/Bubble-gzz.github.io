<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Bubble&#39;s bubble">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Bubble&#39;s bubble">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Bubble">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Bubble's bubble</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bubble's bubble</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"><oOoOoOoOoOo</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/13/%E6%9C%9F%E6%9C%9B%E6%82%96%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/03/13/%E6%9C%9F%E6%9C%9B%E6%82%96%E8%AE%BA/" itemprop="url">期望“悖论”</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-03-13T15:24:03+08:00">
                2024-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>有两个信封，分别装着c元钱、2c元钱。<br>现在随机将两个信封分发给两个玩家，并告知他们其中某个信封中的钱是另一个信封中的两倍。<br>他们只能看到自己拿到的信封内的金额，所以并不知道自己拿到的那份钱更多还是对方拿到的钱更多。<br>但他们可以选择是否提出交换信封的请求，当双方都提出交换请求时，交换成立。<br>他们的目标是使自己最后手中持有的金额数最大，他们应该采取什么策略比较好？</p>
</blockquote>
<p>bub同学给出了这样的策略分析：</p>
<blockquote>
<p>假如我是其中一名玩家，我手中的金额是x，那么交换信封后，会等概率地发生两个随机事件中的一个：<br>事件A：我获得手中金额的双倍，2x元，也就是获得x元收益；<br>事件B：我获得手中金额的一半，0.5x元，也就是获得-0.5x元收益。<br>交换信封的期望收益 <code>E(Gain) = 0.5*(2x-x)+0.5(0.5x-x) = 0.5x-0.25x = 0.25x</code><br><strong>所以选择交换对我来说更有利。</strong></p>
</blockquote>
<p>似乎挺有道理的，但有一个疑点：这本来是一个零和博弈，双方的总收益应该始终为0，那么双方期望收益的和也应该是0，<br>而bub的计算结果却表明双方的期望收益都大于0。哪儿出错了？</p>
<p>这里实际上隐含了一个偷换概念的错误。</p>
<p>不妨对比一下另一位同学ble给出的分析：</p>
<blockquote>
<p>假如我是其中一名玩家，那么那么交换信封后，会等概率地发生两个随机事件中的一个：<br>事件A：我获得手中金额的双倍，也就意味着我手中的金额是c元，交换后获得2c元，净收益c元；<br>事件B：我获得手中金额的一半，也就意味着我手中的金额是2c元，交换后获得c元，净收益-c元。<br>所以期望收益 <code>E(Gain) = 0.5*c + 0.5*(-c) = 0</code><br>如果交换不成功，那么显然收益为0.<br>因此不管是否交换，我的期望收益都是0，<br><strong>交不交换是无所谓的。</strong></p>
</blockquote>
<p>发现区别了吗？</p>
<p>没错，bub同学定义的两个随机事件中，将“手中的金额”全都等同于自己信封里实际的那个金额x了。</p>
<p>不妨让事情更明显，我们将x替换成具体的数字5，也就是一名玩家拿到的金额是5元。那么bub同学的思路就变成：</p>
<blockquote>
<p>假如我是其中一名玩家，我手中的金额是5，那么交换信封后，会等概率地发生两个随机事件中的一个：<br>事件A：5元是较小的那一笔钱，我获得手中金额的双倍，10元，也就是获得5元收益；<br>事件B：5元是较大的那一笔钱，我获得手中金额的一半，2.5元，也就是获得-2.5元收益。</p>
</blockquote>
<p>这时候错误就更明显了，因为在一个固定的随机模型中，5元要么是较大的那一笔钱，要么是较小的那一笔钱，而不可能有时是较大的那笔钱，有时是较小的那笔钱。</p>
<p>的确，玩家手中的钱既可能是较小的那一笔，也有可能是较大的那一笔，但如果说5元既可能是较小的那一笔，也有可能是较大的那一笔，那就很扯了。</p>
<p>不能因为5元碰巧在玩家手里，就将“玩家手中的钱”和“5元”这两个概念划等号。</p>
<p>这让我想起小时候看到的一个很经典的偷换概念的说法：<code>1元=10角，1元*1元=10角*10角=100角=10元</code>，我们都知道1元不可能等于10元，</p>
<p>单位本身就有着数量上的意义，元这个单位本身就代表角这个单位的10倍，所以你不能无视单位去做运算，如果真要运算，也是<code>1元*1元=10角*10角=100角^2=100（1/10元)^2=1元^2</code>，没有任何矛盾，更不用说这个运算本身也没有什么实际意义。</p>
<p>这让我不禁想到世界上很多的矛盾和争吵最终都毫无意义，因为双方根本就不在一个语境下讨论问题，概念都没有统一，还有什么继续讨论的必要呢。概念的定义是非常重要的，就像支配世界的物理法则一样，物理法则有任何漏洞，世界也将崩溃。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/13/Constructor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/09/13/Constructor/" itemprop="url">Constructor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-09-13T18:52:08+08:00">
                2023-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Object-Oriented-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Object-Oriented Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>记录一下关于类的构造函数以及初始化相关的东西。<br>有两大问题，其中一个是隐式默认函数，另一个是构造函数的继承。<br>隐式默认函数是指在用户没有显式定义构造函数的时候编译器自动隐式定义的默认构造函数，由于这是默认添加的，<br>如果没有搞清楚背后的行为很容易造成初始化遗漏的问题。<br>另一个问题是构造函数的继承，当一个子类继承自父类时，继承了属性和方法，但是继承函数呢？继承函数又可能很多，分为默认的和非默认的，<br>这个时候继承的内容似乎又变得更加混乱了。<br>目前似乎没有语言是默认子类继承父类的构造函数的，而是需要显式地定义子类的构造函数或是从父类继承。<br>鉴于这两个问题的复杂和琐碎，各个语言的处理方式不尽相同，所以作一个整理记录。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先有一个各类语言都差不多的逻辑，那就是属性直接赋值是先于构造函数发生的，以java为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    Arr()&#123;a=<span class="number">2</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终a的值会变成2。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="花括号初始化"><a href="#花括号初始化" class="headerlink" title="花括号初始化"></a>花括号初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A = arr&#123;&#125;;              <span class="comment">// ok</span></span><br><span class="line">    arr B = arr&#123;<span class="number">1</span>&#125;;             <span class="comment">// ok</span></span><br><span class="line">    arr C = arr&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>&#125;;    <span class="comment">// ok</span></span><br><span class="line">    arr D = arr&#123;<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>&#125;;    <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当没有定义constructor时，用花括号的内容可以对号入座地进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">arr</span>(<span class="type">int</span> _a, string _b):a&#123;_a&#125;,b&#123;_b&#125;&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A = arr&#123;&#125;;              <span class="comment">// compile error</span></span><br><span class="line">    arr B = arr&#123;<span class="number">1</span>&#125;;             <span class="comment">// compile error</span></span><br><span class="line">    arr C = arr&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>&#125;;    <span class="comment">// ok</span></span><br><span class="line">    arr D = arr&#123;<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>&#125;;    <span class="comment">// compile error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当定义了constructor时，不再执行默认的对号入座初始化，而是调用对应参数格式的constructor<br>没有参数时也是同样的道理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">arr</span>()&#123; a = <span class="number">5</span>; b = <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A = arr&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; A.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; A.b; <span class="comment">//5 hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意花括号初始化隐藏了一个默认值的规则，也就是当填写的参数少于实际需要的参数时，后面的参数默认为0或是其它对应的默认初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout&lt;&lt;A.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;A.b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;A.c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl; <span class="comment">// 1 2 0</span></span><br><span class="line">    <span class="type">int</span> list[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) cout&lt;&lt;list[i]&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 1 2 0 0 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化以及创建临时实例"><a href="#初始化以及创建临时实例" class="headerlink" title="初始化以及创建临时实例"></a>初始化以及创建临时实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">arr</span>(<span class="type">int</span> _a, string _b): a&#123;_a&#125;, <span class="built_in">b</span>(_b) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(arr A)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; A.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; A.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A = &#123;<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    arr B&#123;<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    arr C = <span class="built_in">arr</span>(<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">foo</span>(A);</span><br><span class="line">    <span class="built_in">foo</span>(B);</span><br><span class="line">    <span class="built_in">foo</span>(C);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">arr</span>(<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="built_in">foo</span>(arr&#123;<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">5 hello</span></span><br><span class="line"><span class="comment">5 hello</span></span><br><span class="line"><span class="comment">5 hello</span></span><br><span class="line"><span class="comment">5 hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到不同的创建临时实例的方式，实际上都是调用了对应参数的constructor。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(arr A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;A.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;A.b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;A.c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">foo</span>(arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给没有显式构造函数的类型传递参数时，对号入座法也适用。</p>
<h3 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A;</span><br><span class="line">    cout&lt;&lt;A.a&lt;&lt;endl;</span><br><span class="line">    arr B&#123;&#125;;</span><br><span class="line">    cout&lt;&lt;B.a&lt;&lt;endl;</span><br><span class="line">    arr C = <span class="built_in">arr</span>();</span><br><span class="line">    cout&lt;&lt;C.a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">112197632</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">arr</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr A;</span><br><span class="line">    cout&lt;&lt;A.a&lt;&lt;endl;</span><br><span class="line">    arr B = <span class="built_in">arr</span>();</span><br><span class="line">    cout&lt;&lt;B.a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">-38797312</span></span><br><span class="line"><span class="comment">-421528752</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到不显式地进行初始化导致初始值不干净的问题。查阅资料可知，当没有显式定义constructor的时候，<br>编译器会隐式地定义一个默认的constructor，但这个constructor到底会不会贴心地给属性初始化为默认值，我不好说。<br>所以有两种方法可以确保属性被正确地初始化为默认值：<br>（1）不定义任何constructor，然后用空{}的形式进行对号入座式的初始化<br>（2）显式定义一个不带参数的default constructor，然后在里面手动初始化，实例化的时候可以采用下面几种写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr A; <span class="comment">//默认调用default constructor</span></span><br><span class="line">arr A=<span class="built_in">arr</span>(); <span class="comment">//显式调用default constructor</span></span><br><span class="line">arr A&#123;&#125;; <span class="comment">//显式调用default constructor</span></span><br><span class="line">arr A = &#123;&#125;; <span class="comment">//显式调用default constructor</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">arr</span>(<span class="type">int</span> _a, string _b):a&#123;_a&#125;,b&#123;_b&#125;&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">arr <span class="title">A</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;A.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;A.b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<code>arr A(5, &quot;hello&quot;)</code>代替<code>arr A = arr(5, &quot;hello&quot;)</code>。但是看下面这种情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">arr</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">arr <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">    cout&lt;&lt;A.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;A.b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>却会编译错误，提示A是一个函数。这里是声明了一个没有参数的，返回值为arr的函数A。这也被称为”the most vexing parse”之一。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>下面是最头疼的继承。c++的继承还没有研究，先不说。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>Java如果没有显示定义构造函数，那么会有一个空的默认构造函数。如果用户定义了至少一个构造函数，那么编译器就不会再自动定义空的默认构造函数，这时如果<br>用户希望使用 new A()这种无参数的构造函数，就需要自己手动定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    Arr()&#123;&#125; <span class="comment">//必须要！ 如果去掉，那么*处就会报错，找不到对应格式的构造函数</span></span><br><span class="line">    Arr(<span class="type">int</span> _a, <span class="type">int</span> _b)&#123;</span><br><span class="line">        a=_a; b= _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        <span class="type">Arr</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arr</span>(); <span class="comment">// * </span></span><br><span class="line">        System.out.println(temp.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    Arr()&#123;a=<span class="number">5</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Brr</span> <span class="keyword">extends</span> <span class="title class_">Arr</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        <span class="type">Arr</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arr</span>();</span><br><span class="line">        <span class="type">Brr</span> <span class="variable">temp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brr</span>();</span><br><span class="line">        System.out.println(temp.a + <span class="string">&quot; &quot;</span> + temp2.a); <span class="comment">//5 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Brr默认继承了Arr的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arr</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    Arr(<span class="type">int</span> _a)&#123;a=_a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Brr</span> <span class="keyword">extends</span> <span class="title class_">Arr</span> &#123; <span class="comment">//error:There is no default constructor in Arr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这个时候编译器报错。<br>子类必须显式地在构造函数中调用父类的某个构造函数super(…)，如果没有，那么会默认调用父类的default constructor。<br>第一个例子之所以没有报错是因为父类有default constructor。</p>
<p>其中设计者的逻辑可能是，子类的初始化至少应该符合父类的某种初始化形式，而不是完全脱离父类的初始化?<br>既然子类可以override父类的方法，为什么不能override父类的构造函数呢？<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14250486/why-exactly-do-subclass-constructors-have-to-explicitly-call-super-class-constru#:~:text=This%20is%20required%20because%20the,parameters%20need%20to%20be%20passed">这个链接说的不错</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java中，构造函数不会默认继承，子类在继承父类的时候，每一个构造函数都应当显式地在开头调用父类的某个构造函数。</p>
<h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><h3 id="Instantiation"><a href="#Instantiation" class="headerlink" title="Instantiation"></a>Instantiation</h3><p>Kotlin不用new关键字，直接调用构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bob = Student(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>Kotlin的构造函数比较独特，一个类可以拥有一个primary constructor和若干个secondary constructor，<br>primary constructor用于声明属性和完成必备的初始化，secondary constructor用于额外的初始化，<br>secondary constructor必须显式地调用primary constructor。</p>
<h4 id="Primary-Constructor"><a href="#Primary-Constructor" class="headerlink" title="Primary Constructor"></a>Primary Constructor</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> grade:<span class="built_in">Int</span>, param:<span class="built_in">Int</span>) <span class="comment">//manner A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> grade:<span class="built_in">Int</span>, param:<span class="built_in">Int</span>) <span class="comment">//manner B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> grade:<span class="built_in">Int</span>, param:<span class="built_in">Int</span>)&#123;&#125; <span class="comment">//manner C</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主体部分没有代码的情况下，可以省略花括号，写法C简化成写法B，<br>在没有额外的修饰词的情况下，写法B又可以简写成写法A。<br>出现在参数列表中以val或者var修饰的参数都会默认成为property，否则只是一个用于初始化的临时参数。<br>primary constructor的初始化代码被放在Initializer Block中。<br>代码按照从上到下的顺序依次执行遇到的property initializer和initializer block。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitOrderDemo</span></span>(name: String) &#123;</span><br><span class="line">    <span class="keyword">val</span> firstProperty = <span class="string">&quot;First property: <span class="variable">$name</span>&quot;</span>.also(::println)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;First initializer block that prints <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> secondProperty = <span class="string">&quot;Second property: <span class="subst">$&#123;name.length&#125;</span>&quot;</span>.also(::println)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Second initializer block that prints <span class="subst">$&#123;name.length&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">First property: hello</span></span><br><span class="line"><span class="comment">First initializer block that prints hello</span></span><br><span class="line"><span class="comment">Second property: 5</span></span><br><span class="line"><span class="comment">Second initializer block that prints 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以啥也不写，会有一个默认的空的构造函数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dumb</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value:<span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dumb = Dumb()</span><br><span class="line">    println(<span class="string">&quot;dumb.value: <span class="subst">$&#123;dumb.value&#125;</span>&quot;</span>) <span class="comment">// dumb.value: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Secondary-Constructor"><a href="#Secondary-Constructor" class="headerlink" title="Secondary Constructor"></a>Secondary Constructor</h4><p>二级构造函数的执行发生在主构造函数部分（包括initializer block和property initializer）之后。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constructors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Init block A&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Constructor <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> value:<span class="built_in">Int</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Init block B&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Init block A</span></span><br><span class="line"><span class="comment">Init block B</span></span><br><span class="line"><span class="comment">Constructor 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>二级构造函数必须直接或间接调用一级构造函数（如果有的话）。<br>二级构造函数的参数不允许使用val或者var修饰，只用于传参目的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">var</span> age:<span class="built_in">Int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> grade:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height:<span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span> &#123; println(<span class="string">&quot;constructor A    age: <span class="variable">$age</span>&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(age:<span class="built_in">Int</span>, grade:<span class="built_in">Int</span>):<span class="keyword">this</span>(age)</span><br><span class="line">    &#123;</span><br><span class="line">        println(<span class="string">&quot;constructor B1&quot;</span>)</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(age:<span class="built_in">Int</span>, grade:<span class="built_in">Int</span>, height:<span class="built_in">Int</span>):<span class="keyword">this</span>(age, grade)</span><br><span class="line">    &#123;</span><br><span class="line">        println(<span class="string">&quot;constructor B2&quot;</span>)</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> bob = Student(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">constructor A    age: 1</span></span><br><span class="line"><span class="comment">constructor B1</span></span><br><span class="line"><span class="comment">constructor B2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>没有定义主构造函数，那么二级构造函数就可以没有交集了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dumb</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value:<span class="built_in">Int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> name:String = <span class="string">&quot;someone&quot;</span></span><br><span class="line">    <span class="keyword">constructor</span>(value:<span class="built_in">Int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(name:String)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dumb1 = Dumb(<span class="number">132</span>)</span><br><span class="line">    <span class="keyword">val</span> dumb2 = Dumb(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;dumb1.value: <span class="subst">$&#123;dumb1.value&#125;</span> dumb1.name: <span class="subst">$&#123;dumb1.name&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;dumb2.value: <span class="subst">$&#123;dumb2.value&#125;</span> dumb2.name: <span class="subst">$&#123;dumb2.name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">dumb1.value: 132 dumb1.name: someone</span></span><br><span class="line"><span class="comment">dumb2.value: 5 dumb2.name: hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h4 id="Constructor继承"><a href="#Constructor继承" class="headerlink" title="Constructor继承"></a>Constructor继承</h4><p>不管是直接还是间接，每一个构造函数都必须调用基类的某一个构造函数。<br>其中主构造函数调用时使用基类的名称，而二级构造函数调用时使用关键字super。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx)</span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在继承的时候，子类在保证调用基类构造函数的基础上，同样可以定义自己的property，两者并不冲突。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dumb</span></span>(<span class="keyword">var</span> value:<span class="built_in">Int</span> = <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name:String = <span class="string">&quot;someone&quot;</span></span><br><span class="line">    <span class="keyword">constructor</span>(value:<span class="built_in">Int</span>, name:String):<span class="keyword">this</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigDumb</span></span>(value:<span class="built_in">Int</span>, <span class="keyword">var</span> weight:<span class="built_in">Int</span> = <span class="number">100</span>):Dumb(value)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> bob = Student(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> dumb = BigDumb(<span class="number">5</span>)</span><br><span class="line">    println(<span class="string">&quot;dumb.value: <span class="subst">$&#123;dumb.value&#125;</span>  dumb.name: <span class="subst">$&#123;dumb.weight&#125;</span>&quot;</span>) <span class="comment">//dumb.value: 5  dumb.weight: 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>kotlin比较有意思的一点是使用了两级构造函数，其中主构造函数颇有一种将类变成函数的意味，主构造函数的参数位于整个类的最顶部，<br>是类的DNA，是类最核心的参数，这样可以确保类最关键的参数被传进来，这种设计更加科学合理，可以减少bug。</p>
<p>参考内容: <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs">kotlinlang.org&#x2F;docs</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/10/c-sharp-%E8%AF%AD%E6%B3%95%E4%B9%8Bupcast-downcast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/10/c-sharp-%E8%AF%AD%E6%B3%95%E4%B9%8Bupcast-downcast/" itemprop="url">C# 语法之upcast & downcast</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-10T11:07:39+08:00">
                2022-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C#</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-语法之upcast-amp-downcast"><a href="#C-语法之upcast-amp-downcast" class="headerlink" title="C# 语法之upcast &amp; downcast"></a>C# 语法之upcast &amp; downcast</h1><h3 id="Upcast"><a href="#Upcast" class="headerlink" title="Upcast"></a>Upcast</h3><p>想象一个应用场景，当我想要实现一个物品背包，每个物品槽都是一个Item类型，然而具体的物品都是Item的子类而非Item本身，<br>例如我们有两个class，从Item衍生而出:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Sword</span> : <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> atk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Shield</span> : <span class="title">Item</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> def;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，可以直接将子类存放到基类变量中吗？<br>例如</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sword sword = <span class="keyword">new</span> Sword();</span><br><span class="line">Item item = sword;</span><br></pre></td></tr></table></figure>
<p>答案是肯定的。这个操作就叫作<code>upcast</code>，因为class是向上兼容的，<br>item具有的属性，sword全都具有，因此可以顺理成章地将sword放到item中。<br>但我们还有一些疑问没有解决：<br>1.我们可以使用形如item.atk这样的访问吗？毕竟我们知道我们存储的内容实际上是Sword类型<br>2.这个item中存放的是sword本体吗？还是一个向上兼容后的新对象？<br>我们来实验一下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sword sword = <span class="keyword">new</span> Sword();</span><br><span class="line">sword.atk = <span class="number">1</span>;</span><br><span class="line">Item item = sword;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;item.atk = &quot;</span> + item.atk);</span><br></pre></td></tr></table></figure>
<p><strong>编译失败</strong>。说明无法访问item.atk，合理，因为item的类型是Item，是一个更广泛的概念，万一它存储的不是Sword类型呢？<br>因此这里不能因为你心里知道它是Sword就任由你胡作非为，语法是很严格的，严格才能确保规范和安全嘛。<br>关于第二问，我们暂且无法得知，因为我们没法通过item对atk进行修改，也无法验证这个修改有没有反映到sword本体。<br>别急，看标题就知道，我们还有另一种相反的操作：<code>downcast</code>。</p>
<h3 id="Downcast"><a href="#Downcast" class="headerlink" title="Downcast"></a>Downcast</h3><p>顾名思义，<code>downcast</code>就是将一个父类对象存放到子类对象中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sword sword2 = (Sword)item;</span><br></pre></td></tr></table></figure>
<p>我们新建一个对象sword2，将item强制转化为Sword类型(注意这里必须说清楚你要转化的类型，否则编译也会失败，这也很好理解，因为程序不知道你要转化成什么，万一是Sword的子类呢？也是有可能的哦)，成功了！<br>那我们就好奇了，sword2现在是谁呢？是sword本体呢，还是一个复制品呢？它的atk值是多少呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sword sword = <span class="keyword">new</span> Sword();</span><br><span class="line">sword.atk = <span class="number">1</span>;</span><br><span class="line">Item item = sword;</span><br><span class="line">Sword sword2 = (Sword)item;</span><br><span class="line">sword.atk = <span class="number">5</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;sword2.atk = &quot;</span> + sword2.atk); <span class="comment">// Output: sword2.atk = 5</span></span><br><span class="line">sword2.atk = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;sword.atk = &quot;</span> + sword.atk); <span class="comment">// Output : sword.atk = 10</span></span><br></pre></td></tr></table></figure>
<p>通过上面这个实验，真相已经很显然了，sword2就是sword，虽然经过了item这个中间容器，但sword还是无损地传到了sword2中。<br>综合上面的种种现象，我得出结论：</p>
<blockquote>
<p><code>upcast</code>将子类对象存放到父类对象时，并不是将子类对象进行简化，而是存放了一个子类本体引用，暂时对外隐藏了父类中不存在的内容。</p>
</blockquote>
<p>例如这个例子中，item还是指代sword，只不过暂时无法通过item来访问sword.atk。</p>
<p>不过我们对于<code>downcast</code>似乎还有不太了解的地方。可以将父类转化为子类？怎么听都很扯啊，毕竟子类有父类中不存在的内容，难道c#可以无中生有吗？<br>但上面的downcast之所以可以成功，一个重要因素在于sword2的类型和item中对象的类型是一致的，都是Sword。<br>我们来试试<code>downcast</code>到另一个不同的子类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sword sword = <span class="keyword">new</span> Sword();</span><br><span class="line">sword.atk = <span class="number">1</span>;</span><br><span class="line">Item item = sword;</span><br><span class="line">Shield shield = (Shield) item; <span class="comment">// System.InvalidCastException!!</span></span><br></pre></td></tr></table></figure>
<p>结果出现了异常。这说明<code>downcast</code>也不是什么魔法。如果父类中存放的对象类型和<code>downcast</code>目标类型不兼容，也是会有问题的。<br>而这种问题编译时是无法发现的，只有运行时才会检验出来咯。</p>
<p>知道了这些，我们就可以放心地使用<code>upcast</code>和<code>downcast</code>来写背包功能啦！当然再比如可插拔式的敌人AI（就像芯片那样）也可以用同样的方法！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/11/Unity%E4%B9%8B%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84nullReferenceException/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/11/Unity%E4%B9%8B%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84nullReferenceException/" itemprop="url">Unity之莫名其妙的nullReferenceException</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-11T20:16:51+08:00">
                2022-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index">
                    <span itemprop="name">unity</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/tip/" itemprop="url" rel="index">
                    <span itemprop="name">tip</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WaveJoint&gt; joints;</span><br><span class="line">...</span><br><span class="line">WaveJoint newJoint = newJointObj.GetComponent&lt;WaveJoint&gt;();</span><br><span class="line">joints.Add(newJoint);            </span><br></pre></td></tr></table></figure>
<p>大概有这么三句相关的代码。<br>程序在第三句处发生了nullReferenceException.<br>我第一反应是newJoint是null，可能是GetComponent有什么问题。<br>可是半天都没发现有任何问题。<br>弄到最后原来是joints是null。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原来我一直用c++，c++可以不用new就实例化一个对象，殊不知c#不行。<br>和c++可以显式地使用对象指针不同，c#等面向对象语言都是默认使用对象指针，只不过看起来没有指针符号。<br>因此c++可以不用new就创建一个类的实例（这个实例占用的是栈的内存），<br>而c#就不行了，joints会默认是一个空指针，只能通过new来申请空间并且将指针保存到joints中。<br>所以改成下面的写法就没问题了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WaveJoint&gt; joints = <span class="keyword">new</span> List&lt;WaveJoint&gt;();</span><br><span class="line">...</span><br><span class="line">WaveJoint newJoint = newJointObj.GetComponent&lt;WaveJoint&gt;();</span><br><span class="line">joints.Add(newJoint);            </span><br></pre></td></tr></table></figure>
<p>麻了。几个小时绕圈子。不过这下一辈子忘不掉了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/" itemprop="url">unity基础概念:anchor & pivot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-11T10:25:54+08:00">
                2022-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index">
                    <span itemprop="name">unity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UI类的对象都有几个属性，position，anchor，pivot，这些分别是干什么的呢？</p>
<h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>首先pivot比较容易理解。也就是旋转中心。图中的圆圈标出了pivot的位置。<br><img src="/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/pivot0.png" alt="pivot"><br><code>pivot(rx,ry)</code>意思是旋转中心位于边框的<code>(sizeX*rx,sizeY*ry)</code>处。<br><code>pivot(0.5,0.5)</code>，意思是旋转中心位于边框的正中心。<br><img src="/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/pivot.png" alt="tool handle position"><br>注意将tool handle position切换为pivot模式，否则代表pivot的圆圈无法拖动，也不会跟随数值而改变显示的位置。</p>
<h2 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h2><p>anchor是锚点的意思，也就是基准线。minX,maxX,minY,maxY分别表示了左右下上四条基准线的位置（和pivot一样同样是比例值）<br>不管canvas如何缩放，anchor的四条基准线位置始终和canvas成固定比例。<br><img src="/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/anchor.png" alt="anchor"></p>
<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position描述的是UI的真实边框相对于基准线的偏移量。<br>例如top&#x3D;20，就代表UI上边界距离基准线20单位。<br><img src="/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/position.png" alt="position-1"><br>注意这里的距离都是以向内部为正方向。也就是说，正的偏移量代表朝内偏移，负的代表朝外偏移。<br><img src="/2022/07/11/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-anchor-pivot/position2.png" alt="position-2"><br>特殊情况：当anchor四个顶点有重合，即变成一个点或者一条线的时候，压扁的那个维度就不再用两个偏移量表示，而是用pos表示位置，宽度或者高度来表示两条边的位置。这个也大同小异。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/10/unity%E8%A7%A3%E6%83%91%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/10/unity%E8%A7%A3%E6%83%91%E7%B3%BB%E5%88%97/" itemprop="url">unity解惑系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-10T21:34:10+08:00">
                2022-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index">
                    <span itemprop="name">unity</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/tips/" itemprop="url" rel="index">
                    <span itemprop="name">tips</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gameObject-getComponent-vs-getComponent"><a href="#gameObject-getComponent-vs-getComponent" class="headerlink" title="gameObject.getComponent vs getComponent"></a>gameObject.getComponent vs getComponent</h2><p>我一直以为gameObject.getComponent是类的一个静态方法。<br>实际上是script类继承的monoBehavior里面的一个property叫gameObject，表示脚本依附的游戏对象。<br>这样就很清晰了。<br>前者是调用了gameObject的getComponent方法，而后者是调用了monoBehavior的getComponent的方法。<br>二者殊途同归。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/10/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/10/unity%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-transform/" itemprop="url">unity基础概念:transform</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-10T21:29:07+08:00">
                2022-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index">
                    <span itemprop="name">unity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>transform并不是只能用来表示坐标、大小、旋转等基本信息。<br>实际上transform的一个重要功能在于维持hierarchy。也就是结构树。<br>我觉得这是unity很反直觉的一个地方，这一点不如godot那么直观（godot中每个node在结构树中的位置就代表了它的位置，所见即所得）。<br>我一直以为有什么办法直接表示gameObject的结构树，然而unity似乎只有transform相关的结构树。<br>目前我知道的是，这个结构树似乎足够使用了（子节点继承继承父节点的transform属性，以及移动、删除）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/10/unity%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-script/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/10/unity%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-script/" itemprop="url">unity基础概念:script</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-10T20:16:16+08:00">
                2022-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/unity/" itemprop="url" rel="index">
                    <span itemprop="name">unity</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>script是unity中的一个基本概念，即脚本，也就是写代码的地方，似乎没什么好说的。<br>但是有一些概念我还是困惑了好一阵子，所以在这边小结一下。</p>
<h2 id="script也是component"><a href="#script也是component" class="headerlink" title="script也是component"></a>script也是component</h2><p>首先，script并没有什么特别，它和其它component一样，是依附在gameObject上的一部分。<br>script每一帧被调用实际上和其它component每一帧被计算是一个道理。</p>
<h2 id="script本质是实例化的实现了特定接口的class"><a href="#script本质是实例化的实现了特定接口的class" class="headerlink" title="script本质是实例化的实现了特定接口的class"></a>script本质是实例化的实现了特定接口的class</h2><p>虽说script也是component，但它和其它component还是有些不同。<br><img src="/2022/07/10/unity%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-script/picture1.png" alt="figure 1"><br>图中可以看到，其它component直接给出了类型名称，而script却是先给出类名称，然后括号里才是script。<br>我是这么理解的：一个脚本的本质是一个实例化的类，而不是一个笼统的脚本类。<br>关于实例化，这是面向对象里面的常识，我们都知道一个script在代码的class块中只是给出了定义，只有在代码中显式地进行实例化才会作为一个实体。但是在面对script的时候我却先入为主地忽略了这个机制，因为script通常依附在gameObject上，被引擎隐式地自动实例化了。而实际上，依附在gameObject上的脚本也是一个实例，它的本质实际上不是脚本类，而是对应的实例化的类。<br>一旦有了这一点认识，下面的代码也就不难理解：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Player player1 = GetComponent&lt;Player&gt;(); <span class="comment">//  并不是GetComponent&lt;script&gt;()</span></span><br><span class="line">player1.attack(); <span class="comment">// 和调用一个实例化对象的形式完全一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="并不是只有monobehavior"><a href="#并不是只有monobehavior" class="headerlink" title="并不是只有monobehavior"></a>并不是只有monobehavior</h2><p>上面提到，script也不过是一类特殊的实例化后的class，因此更一般的class实际上并不需要符合script的所有特点。<br>一般的class并不继承monobehavior。自然也不需要实现start、update等等method。<br>因此如果想要写一个纯数据结构，那用一般的class就行了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>有了上面这些认识，我觉得我可以清楚地意识到我写的代码究竟保存在什么地方，究竟作为什么对象，在什么环节起了作用。<br>这样我也可以更合理准确地安排我的代码结构。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%86%8D%E6%84%9F%E5%88%B0%E5%AD%A4%E7%8B%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%86%8D%E6%84%9F%E5%88%B0%E5%AD%A4%E7%8B%AC/" itemprop="url">为什么我不再感到孤独</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-05T15:27:55+08:00">
                2022-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bubble/" itemprop="url" rel="index">
                    <span itemprop="name">bubble</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我觉得，孤独，源于内心世界的空虚。一个内心世界空虚的人，无法证明自己存在的意义，也没有支持自己独自活下去的能量，于是渴望向外界寻求帮助，建立亲密关系，被动地获得精神的养分。</p>
<p>小时候的我虽然大多数时间一个人玩，但我从来不感到孤独。一个人画画，一个人看书，一个人玩玩具，那个时候我的精神世界是丰富多彩的。</p>
<p>但自从上了中学，我就不在纸上画小游戏了，我也不玩玩具了，我的世界开始被应试教育占据。年级排名，莫名其妙的自尊，对名牌大学的迷信，来自同龄人的压力，对未来生活的忧虑……各种bullshit开始啃食我的大脑。渐渐地我的内心世界不再丰富，而是开始尝试和那些根本不适合我的东西同质化。虽然我仍然习惯独处，但我开始感到孤独。这段时间，我并不是我，而是“自以为的别人眼中的我”，是无数个通过对外界的观察习得的别的形象。我开始有一种感觉，在不同的人面前，我是不同的形象。这种感觉是不自觉的，虽然是我自己表演出来的形象，但反过来却控制了我自己的行为，让我不得不顺着这种潜意识中的自我定位去表演。</p>
<p>到了高中，这种情况越来越严重，我很少花时间去沉浸到自己的内心世界中，或者说即使在冥想，也无从了解真正的自己。我的内心世界此刻已经一片混沌，我不知道自己想要什么，但我能感觉到强烈的空虚和恐惧。我越来越习惯于被动地接受外界的信息，对周围的人进行模仿，看到别人做什么，我总是觉得自己也应该做；总觉得别人比自己强，而自己特别废物。只有学习别人的行为，才能减轻自己的不安和恐惧。</p>
<p>内心世界的空虚，也产生了一些奇奇怪怪的感情，爱上了一些不应该去爱的人，讨厌了一些不应该讨厌的人。这个时期爱上一个人，就像带电物体吸引轻小物体一样，内心空虚，没有主见也不够自信的我，很容易被别人外在的表面的特质吸引，从别人身上获得精神养分，产生一种廉价的仰慕。而讨厌一个人，就像一个可悲的低等生物，受到一点外界刺激就会表现出很强的攻击性，以为全世界都要威胁自己的生存，无法正确地理解和原谅。内心世界的空虚，使我在感情问题上非常被动，无法很好地控制自己。</p>
<p>回头一看，自己原来一直在倒退啊。这么多年，我本可以变得更好，好十倍，一百倍。但我稀里糊涂地走来，甚至不如童年时期的自己。</p>
<p>所幸在大学，我认识了一些自身非常棒的朋友，接触到了更广阔的世界，我逐渐开始重新认识自己，摒弃了一些一直坚信的东西，找到了自己归属的维度。我发现世界是多维的，如果只是在一个限定的维度上去比较，那么自然，人有高低之分。但这又什么意义呢？把一个在A维度很高大的人，投影到B维度，将ta贬低得一文不值，这有什么意义呢？或者说，一个A维度的人，本来就和B维度的夹角非常接近正交，那么ta怎么努力，在B维度的投影都几乎是在原地踏步，这不是很可悲吗？而我一直以来都是这么做的，对自己，对别人也是。我觉得世界上很多人也都是这么做的，即使不然，至少应试教育就是这么做的。</p>
<p>这个时候，我才发现，童年时候的那种感觉回来了。我开始用自己的心去感受世界，我的内心开始安静下来，不再恐慌地追随别人的脚步。仿佛回到了那个宁静的下午，阳光照在房间的地板上，一个孩子安静地摆弄着眼前的玩具，幻想出一个奇幻的世界，他就是这个世界的上帝。仿佛回到了那个年纪，那个能够和几何，和代数，和物理，一切知识做朋友的年纪，回到了那个学习纯粹是由某种欲望驱动的年纪……</p>
<p>我其实不期望自己通过知识来提高自己的社会地位，也不需要什么社会地位。我不是知识的奴隶，反过来，知识也不是我的奴隶。我需要用到知识的时候，我会很乐意和知识交朋友；而我不需要用到它的时候，我也希望它不要打扰我，让我身心俱疲。当我有灵感的时候，即使没有任何报酬，我也会自觉地去创造和分享新的知识；而当我没有灵感的时候，我绝对不想故作高深地去把任何东西学术化。这不就像两个人交朋友吗。双方应该保持很好的分寸感，在必要的时候给予，在不必要的时候保持距离，不要为了维持某个关系而去维持。</p>
<p>言归正传，总之我在舍弃一些东西。舍弃一些让我觉得很累，但一度以为正确的，对人生有投资价值的东西。我天生不擅长当投机者，我很迟钝。投资这种事情，只让我感受到眼前的痛苦，我也不确定我将来能够有所收获。我只知道，我需要让自己变成什么样，而我慢慢似乎发现了答案。人生苦短，我不知道我还剩下多少个十年。所以，去他妈的投资。</p>
<p>想想挺讽刺的。回顾这一路的成长，似乎是一次离家出走。背叛了最初的模样，获得了自以为是的成熟。直到经历，接纳，舍弃，顿悟……转了一圈，发现心中向往的那个花园，竟是最初生活的家。也许这个房子已经修葺一新，但我知道，这就是那个地方，这里有我降临到这个世界上的痕迹。无数不自觉地伪装出来的精神分裂一般的形象，全部烟消云散，只剩下那个真实的自己。听觉，视觉，味觉，嗅觉，触觉，还有，自觉，全部回来了。</p>
<p>所以我不感到孤独了，因为我的内心能够自给自足。如果有一个对上电波的朋友，那我感激不尽，当然，随着年龄的增长，我对ta的性别，外貌的要求会越来越淡，直到ta在我的眼里，可以只是一个虚拟人。即使没有，也无所谓了。一个人再孤单，也永远可以有自己的灵魂安心地陪伴在身边。</p>
<p>我开始发现并且确信，我想做的事情包括绘画，开发游戏，创作音乐，写文字……因为我热爱想象和表达，我喜欢和创造有关的活动。我讨厌为了一个现实而无趣的目标去努力，至少这对我来说没有什么吸引力。我对生活的要求不高，有一个自己的小屋，有吃有穿，偶尔吃顿好的，这就够了。我也没什么远大的志向去创造前沿的科技，因为人类已经创造出的文明就已经是一个巨大的宝库，足够我穷其一生去探索。正如先了解自己，再去谈其它。相比于追求未知，我还是更喜欢探索已知。我想在已经生成的世界中活出自己的痕迹。或者到了某个时候，我对已经生成的世界不满意了，我再去努力地改变它。</p>
<p>我也不知道。确实上述文字有些偏激，但对我自己来说，我很需要自己对自己说这么一段话，管它呢。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/17/%E6%95%B0%E5%AD%A6%E5%A6%82%E6%9E%9C%E5%87%BA%E4%BA%86%E9%97%AE%E9%A2%98%EF%BC%8C%E9%82%A3%E4%B8%80%E5%AE%9A%E6%98%AF%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bubble">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/beer.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bubble's bubble">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/17/%E6%95%B0%E5%AD%A6%E5%A6%82%E6%9E%9C%E5%87%BA%E4%BA%86%E9%97%AE%E9%A2%98%EF%BC%8C%E9%82%A3%E4%B8%80%E5%AE%9A%E6%98%AF%E6%88%91%E7%9A%84%E9%97%AE%E9%A2%98/" itemprop="url">如果数学出了问题，那一定是我的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-17T19:45:42+08:00">
                2022-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bubble/" itemprop="url" rel="index">
                    <span itemprop="name">bubble</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天下午四点左右开始困扰到刚才七点半，此过程非常痛苦，痛苦到怀疑人生。<br>因为我知道，数学不会出问题，如果出了问题，那一定是我自己的问题，我出了大问题。</p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>下午的计组课，本以为是和平的一堂课，但听了一耳朵之后突然意识到有些不对劲。<br>那就是补码的乘法运算。<br>在我的世界观中，原码转补码就是取模，<br>4位有符号整数的补码就是对<code>16</code>取模，32位有符号整数的补码就是对<code>4,294,967,296</code>取模。<br>在我的世界观中，我还知道一个关于取模的运算律:<code>(A*B)%M = (A%M)*(B%M) %M</code><br>所以很显然啊，<code>[A*B]补 = [A]补*[B]补 (自然溢出后)</code><br>因为比如在4位有符号整数中，<code>[X补] = X%16</code><br>所以有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[A*B]补</span><br><span class="line">=(A*B)%16</span><br><span class="line">=(A%16)*(B%16)%16</span><br><span class="line">=[A]补*[B]补（自然溢出）</span><br></pre></td></tr></table></figure>

<p>我也用程序进行了验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    unsigned int _a = a, _b = b, _c, _d;</span><br><span class="line">    _c = _a * _b; //补码相乘</span><br><span class="line">    _d = a * b; //相乘后再转补码</span><br><span class="line">    printf(&quot;%u %u\n&quot;, _c, _d); //结果相同</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可是如果是这么简单，为什么老师开始写满满一黑板啊？还有这个ppt是这么回事啊？怎么都在算！！！</strong><br>我开始意识到，哦，老师讲的例子都是定点小数……<br>定点小数可能和整数不太一样吧……<br>诶不对啊，定点小数不就是<strong>对2取模</strong>吗？本质上没啥区别吧？<br>整数可以的话，小数也可以吧？<br>但是从老师的讲述以及书本知识来看，<strong>小数没法直接补码相乘，至少负数和负数没法直接相乘</strong>。<br>我惊了。</p>
<h2 id="数学天才"><a href="#数学天才" class="headerlink" title="数学天才"></a><del>数学天才</del></h2><p>书上写着，当<code>Y&lt;0</code>时，记<code>[Y]补=1.Y1Y2..Yn</code>，<br>有<code>[X*Y]补 = [X]补*0.Y1Y2..Yn + [-X]补</code><br>我想着，这么写虽然是对的，但是难道不能化简为<code>[X*Y]补 = [X]补*[Y]补</code>吗<br>于是我写出了下面这个<del>十分正确的</del>推算过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在模2的意义下:</span><br><span class="line">[X*Y]补</span><br><span class="line">=[X]补*0.Y1Y2..Yn + [-X]补    //书上的公式</span><br><span class="line">=[X]补*0.Y1Y2..Yn + (2-[X]补)</span><br><span class="line">=[X]补*0.Y1Y2..Yn - [X]补</span><br><span class="line">=[X]补*(0.Y1Y2..Yn - 1)</span><br><span class="line">=[X]补*(0.Y1Y2..Yn + 1)</span><br><span class="line">=[X]补*[Y]补                  //~~完全胜利~~</span><br></pre></td></tr></table></figure>
<p>太好啦，这就说明书上的做法其实并不是唯一做法，事实上存在更简单的做法。<br>书上这么做，一定是为了方便后续的算法优化~~<br>带着胜利的心情我带入了一组样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[X]补=1.001</span><br><span class="line">[Y]补=1.011</span><br><span class="line">[-X]补=0.111</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[X]补*[Y]补</span><br><span class="line">=1.001*1.011</span><br><span class="line">=1.001*(1+0.011)</span><br><span class="line">=1.001*0.011+1.001       //result_A</span><br><span class="line"></span><br><span class="line">[X]补*0.Y1Y2..Yn+[-X]补</span><br><span class="line">=1.001*0.011+0.111       //result_B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>啊咧？？很显然在模2意义下<code>result_A</code>和<code>result_B</code>并不相等啊<br>可是刚才明明推出了<code>[X]补*0.Y1Y2..Yn+[-X]补 = [X]补*[Y]补</code><br>这是什么新型悖论？<br>我一直很清楚自己的运算基本功有多么糟糕，但我又花了十几分钟，得到的只是若干次的同样的结果。<br>我开始怀疑人生了。</p>
<h2 id="察觉"><a href="#察觉" class="headerlink" title="察觉"></a>察觉</h2><p>我知道上面两个事实是矛盾的。这两个里面必定至少有一个是错的。<br>看着这本写满公式的教材，再看看实名认证的发明了<em>Booth算法</em>的Booth夫妇……<br>我知道，99.9999%的概率，我推出的那个等式是错的<br>这里面一定有什么地方是算错了。<br>我猜一定是<strong>取模</strong>。<br>经过一番挣扎，我突然发现了一个式子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1.001*(0.011-1)%2</span><br><span class="line">=1.001*(0.011+1)%2</span><br></pre></td></tr></table></figure>
<p>上面这个等式显然是错的，因为上下的值相差了<code>2*1.001 = 2.002</code>，它们在<code>模2</code>的意义下相差<code>0.002</code>，并不是同余关系<br>可是如果这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2*1.001 %2 = (2%2)*1.001 %2 = 0*1.001 %2 = 0</span><br></pre></td></tr></table></figure>
<p><code>0 = 0.002</code>可不太对劲啊。<br>所以取模对小数不适用吗？？</p>
<h2 id="重生"><a href="#重生" class="headerlink" title="重生"></a>重生</h2><p>我开始反思自己对取模的理解。<br>取模似乎是一种理所当然的东西，我都没有仔细想过它的合理性。<br>就好像苹果熟了就会掉到地上，而不会飞到天上一样。<br>来吧，<code>(A+B)%M = ( A%M + B%M )%M</code>，果真如此么？<br>果真如此。</p>
<blockquote>
<p>我可以想象有一个操场，一圈的长度为<code>M</code>。<br>那么<code>左边的式子</code>可以理解为<code>我从起点出发，一口气跑了(A+B)的路程，停留在哪个位置</code>。<br>而<code>右边的式子</code>可以理解为<code>我从起点出发，先跑了A的路程，然后原地休息片刻，继续跑了B的路程，最后停留在哪个位置</code>。<br>用脚指头想都知道，这两个是等价的，而且A和B可以是小数。</p>
</blockquote>
<p>那么接下来，<code>A*B %M = A*(B%M) %M</code>，果真如此么？</p>
<blockquote>
<p>左边的式子可以理解为我跑了A次，<code>每一次</code>都从上次结尾的位置出发，接着跑B的路程。<br>右边的式子可以理解为我跑了A次，<code>每一次</code>都从上次结尾的位置出发，接着跑B的路程，但是我发现B每包含完整的一圈，我就可以少跑这一圈，因为这是在做无用功。<br>也就是说在<code>每一次</code>结束的时候，<code>B</code>和<code>B%M</code>的实际效果是一样的，都会让我到达操场的同一个位置。</p>
</blockquote>
<p>所以当A是整数的时候，这个似乎没有任何问题。<br>但比较tricky的一点就是，<strong>当A是小数的时候，这个例子在概念上出现了根本性的区别。</strong><br>因为现在A可以取任意值，所以就没有<code>每一次</code>的概念。刚才我只会在跑完一次之后比较两种描述中我的位置是否相同，<br>可是当A可以取任意值的时候，这样的比较实际上成了一个连续的比较，也就是在每一个时间点的比较（假设规定两式中的<code>每一次</code>所耗费的时间长度相同）。<br>只要在某个时间点（对应某个A），在两种描述中我的位置不同，那就以为着存在一个A，使得这两个式子不相等。<br>这就好比体育课，<code>400m</code>的操场上有两个同学，同学甲用5分钟跑了2.5圈<code>B1=2.5*400</code>，同学乙用5分钟跑了0.5圈<code>B2=0.5*400</code>，他们跑的路程关于400是同余的<br>如果体育老师等他们出发之后就一直在终点玩手机，<strong>等他们都说跑完了再抬头看一眼</strong>，那么老师只知道这两个人都跑到同一个位置，却不知道他们跑的路程不同。<br>但如果老师<strong>一直盯着他俩看</strong>，在中途就可以发现两个人的位置并不相同，也就是A取任意数的时候，可以发现<code>A*B1%400 != A*B2%400</code>。</p>
<p>回头看我推导的那个式子中的一步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模2意义下</span><br><span class="line"> [X]补*(0.Y1Y2..Yn - 1)</span><br><span class="line">=[X]补*(0.Y1Y2..Yn + 1)</span><br></pre></td></tr></table></figure>
<p>这里[X]补并不是整数，因此这里不能用同余的性质。<br>破案了。</p>
<p>所以小数的补码乘法确实不能简单地用补码相乘。<br>所以数学确实没有错。<br>所以再次发现自己是小丑。<br>但至少是一个安心的小丑啦~~~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/beer.png"
                alt="Bubble" />
            
              <p class="site-author-name" itemprop="name">Bubble</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Bubble-gzz" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://bubble327670@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                My Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://leoleoasd.me/" title="Leo" target="_blank">Leo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.bearxiong.xyz/" title="Littlebear" target="_blank">Littlebear</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bubble</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
